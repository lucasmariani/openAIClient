//
//  InputType.swift
//  openAIClient
//
//  Created by Lucas on 12.06.25.
//

import Foundation

// MARK: - InputType

/// Text, image, or file inputs to the model, used to generate a response.
///
/// Learn more:
///
/// [Text inputs and outputs](https://platform.openai.com/docs/guides/text)
/// [Image inputs](https://platform.openai.com/docs/guides/images)
/// [File inputs](https://platform.openai.com/docs/guides/pdf-files)
/// [Conversation state](https://platform.openai.com/docs/guides/conversation-state)
/// [Function calling](https://platform.openai.com/docs/guides/function-calling)
public enum OAInputType: Codable, Sendable {
    /// A text input to the model, equivalent to a text input with the user role.
    case string(String)
    
    /// A list of one or many input items to the model, containing different content types.
    case array([InputItem])
    
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        
        if let text = try? container.decode(String.self) {
            self = .string(text)
        } else if let array = try? container.decode([InputItem].self) {
            self = .array(array)
        } else {
            throw DecodingError.dataCorruptedError(
                in: container,
                debugDescription: "Input must be a string or an array of input items")
        }
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .string(let text):
            try container.encode(text)
        case .array(let items):
            try container.encode(items)
        }
    }
    
}

// MARK: - InputItem

/// An item representing part of the context for the response to be generated by the model.
/// Can contain text, images, and audio inputs, as well as previous assistant responses and tool call outputs.
public enum InputItem: Codable, Sendable {
    /// Input message with role and content
    case message(InputMessage)
    
    /// Output message from the model (for conversation history)
    case outputMessage(OutputMessage)
    
    /// File search tool call
    case fileSearchToolCall(FileSearchToolCall)
    
    /// Function tool call
    case functionToolCall(FunctionToolCall)
    
    /// Function tool call output
    case functionToolCallOutput(FunctionToolCallOutput)
    
    /// Other input item types can be added here as needed
    
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let type = try container.decode(String.self, forKey: .type)
        
        switch type {
        case "message":
            self = try .message(InputMessage(from: decoder))
        case "file_search_call":
            self = try .fileSearchToolCall(FileSearchToolCall(from: decoder))
        case "function_call":
            self = try .functionToolCall(FunctionToolCall(from: decoder))
        case "function_call_output":
            self = try .functionToolCallOutput(FunctionToolCallOutput(from: decoder))
        default:
            // Try to decode as message if type is not recognized
            self = try .message(InputMessage(from: decoder))
        }
    }
    
    public func encode(to encoder: Encoder) throws {
        switch self {
        case .message(let message):
            try message.encode(to: encoder)
        case .outputMessage(let message):
            try message.encode(to: encoder)
        case .fileSearchToolCall(let call):
            try call.encode(to: encoder)
        case .functionToolCall(let call):
            try call.encode(to: encoder)
        case .functionToolCallOutput(let output):
            try output.encode(to: encoder)
        }
    }
    
    private enum CodingKeys: String, CodingKey {
        case type
        case role
    }
}

// MARK: - InputMessage

/// A message input to the model with a role indicating instruction following hierarchy
public struct InputMessage: Codable, Sendable {
    public init(role: String, content: MessageContent, type: String? = "message", status: String? = nil, id: String? = nil) {
        self.role = role
        self.content = content
        self.type = type
        self.status = status
        self.id = id
    }
    
    /// The role of the message input (user, system, assistant, developer)
    public let role: String
    
    /// The content of the message
    public let content: MessageContent
    
    /// The type of the message input. Always "message"
    public let type: String?
    
    /// The status of item. Populated when items are returned via API
    public let status: String?
    
    /// The unique ID of the message (for assistant messages with response IDs)
    public let id: String?
    
}

// MARK: - MessageContent

/// Content for messages - can be string or array of content items
public enum MessageContent: Codable, Sendable {
    /// Text input as string
    case text(String)
    
    /// Array of content items
    case array([ContentItem])
    
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        
        if let text = try? container.decode(String.self) {
            self = .text(text)
        } else if let array = try? container.decode([ContentItem].self) {
            self = .array(array)
        } else {
            throw DecodingError.dataCorruptedError(
                in: container,
                debugDescription: "Content must be a string or an array of content items")
        }
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .text(let text):
            try container.encode(text)
        case .array(let items):
            try container.encode(items)
        }
    }
}

// MARK: - ContentItem

/// Content item types for messages
public enum ContentItem: Codable, Sendable {
    /// Text content
    case text(TextContent)
    
    /// Image content
    case image(ImageContent)
    
    /// File content
    case file(FileContent)
    
    /// Audio content
    case audio(AudioContent)
    
    /// Output text (for assistant messages)
    case outputText(OutputTextContent)
    
    /// Refusal (for assistant messages)
    case refusal(RefusalContent)
    
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let type = try container.decode(String.self, forKey: .type)
        
        let singleValueContainer = try decoder.singleValueContainer()
        
        switch type {
        case "input_text":
            self = try .text(singleValueContainer.decode(TextContent.self))
            
        case "input_image":
            self = try .image(singleValueContainer.decode(ImageContent.self))
            
        case "input_file":
            self = try .file(singleValueContainer.decode(FileContent.self))
            
        case "input_audio":
            self = try .audio(singleValueContainer.decode(AudioContent.self))
            
        case "output_text":
            self = try .outputText(singleValueContainer.decode(OutputTextContent.self))
            
        case "refusal":
            self = try .refusal(singleValueContainer.decode(RefusalContent.self))
            
        default:
            throw DecodingError.dataCorruptedError(
                forKey: .type,
                in: container,
                debugDescription: "Unknown content type: \(type)")
        }
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        
        switch self {
        case .text(let text):
            try container.encode(text)
        case .image(let image):
            try container.encode(image)
        case .file(let file):
            try container.encode(file)
        case .audio(let audio):
            try container.encode(audio)
        case .outputText(let output):
            try container.encode(output)
        case .refusal(let refusal):
            try container.encode(refusal)
        }
    }
    
    private enum CodingKeys: String, CodingKey {
        case type
    }
}

// MARK: - TextContent

/// Text content structure
public struct TextContent: Codable, Sendable {
    /// The text content
    public let text: String
    
    /// The type of content, always "input_text"
    public let type = "input_text"
    
    public init(text: String) {
        self.text = text
    }
    
    enum CodingKeys: String, CodingKey {
        case text
        case type
    }
}

// MARK: - ImageContent

/// Image content structure
public struct ImageContent: Codable, Sendable {
    public init(detail: String = "auto", fileId: String? = nil, imageUrl: String? = nil) {
        self.detail = detail
        self.fileId = fileId
        self.imageUrl = imageUrl
    }
    
    /// The type of content, always "input_image"
    public let type = "input_image"
    
    /// The detail level of the image. One of high, low, or auto. Defaults to auto
    public let detail: String
    
    /// The ID of the file to be sent to the model
    public let fileId: String?
    
    /// The URL of the image to be sent to the model. A fully qualified URL or base64 encoded image in a data URL
    public let imageUrl: String?
    
    enum CodingKeys: String, CodingKey {
        case type
        case detail
        case fileId = "file_id"
        case imageUrl = "image_url"
    }
}

// MARK: - FileContent

/// File content structure
public struct FileContent: Codable, Sendable {
    public init(fileData: String? = nil, fileId: String? = nil, filename: String? = nil) {
        self.fileData = fileData
        self.fileId = fileId
        self.filename = filename
    }
    
    /// The type of content, always "input_file"
    public let type = "input_file"
    
    /// The content of the file to be sent to the model
    public let fileData: String?
    
    /// The ID of the file to be sent to the model
    public let fileId: String?
    
    /// The name of the file to be sent to the model
    public let filename: String?
    
    enum CodingKeys: String, CodingKey {
        case type
        case fileData = "file_data"
        case fileId = "file_id"
        case filename
    }
}

// MARK: - AudioContent

/// Audio content structure
public struct AudioContent: Codable, Sendable {
    /// The audio data
    public let data: String
    
    /// The format of the audio
    public let format: String
    
    /// The type of content, always "input_audio"
    public let type = "input_audio"
    
    public init(data: String, format: String) {
        self.data = data
        self.format = format
    }
    
    enum CodingKeys: String, CodingKey {
        case data
        case format
        case type
    }
}

// MARK: - OutputTextContent

/// A text output from the model
public struct OutputTextContent: Codable, Sendable {
    public init(text: String, annotations: [String]? = nil) {
        self.text = text
        self.annotations = annotations
    }
    
    /// Custom encoding/decoding to handle annotations
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        text = try container.decode(String.self, forKey: .text)
        annotations = nil // Skip decoding annotations for now
    }
    
    /// The text content
    public let text: String
    
    /// Annotations in the text, if any
    public let annotations: [String]? // Simplified to strings for now
    
    /// The type of the content. Always "output_text"
    public let type = "output_text"
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(text, forKey: .text)
        try container.encode(type, forKey: .type)
        // Skip encoding annotations for now
    }
    
    enum CodingKeys: String, CodingKey {
        case text
        case annotations
        case type
    }
    
}

// MARK: - RefusalContent

/// A refusal from the model
public struct RefusalContent: Codable, Sendable {
    /// The refusal explanation from the model
    public let refusal: String
    
    /// The type of the refusal. Always "refusal"
    public let type = "refusal"
    
    public init(refusal: String) {
        self.refusal = refusal
    }
}

// MARK: - OutputMessage

/// An output message from the model (used in conversation history)
public struct OutputMessage: Codable, Sendable {
    public init(content: [ContentItem], id: String, role: String = "assistant", status: String, type: String = "message") {
        self.content = content
        self.id = id
        self.role = role
        self.status = status
        self.type = type
    }
    
    /// The content of the output message
    public let content: [ContentItem]
    
    /// The unique ID of the output message
    public let id: String
    
    /// The role of the output message. Always "assistant"
    public let role: String
    
    /// The status of the message. One of in_progress, completed, or incomplete
    public let status: String
    
    /// The type of the output message. Always "message"
    public let type: String
    
}

// MARK: - FileSearchToolCall

/// File search tool call
public struct FileSearchToolCall: Codable, Sendable {
    public let id: String
    public let queries: [String]
    public let status: String
    public let type = "file_search_call"
    public let results: [FileSearchResult]?
    
    public struct FileSearchResult: Codable, Sendable {
        public let attributes: [String: String]?
        public let fileId: String?
        public let filename: String?
        public let score: Double?
        public let text: String?
        
        enum CodingKeys: String, CodingKey {
            case attributes
            case fileId = "file_id"
            case filename, score, text
        }
    }
}

// MARK: - FunctionToolCall

/// Function tool call
public struct FunctionToolCall: Codable, Sendable {
    public init(arguments: String, callId: String, name: String, id: String? = nil, status: String? = nil) {
        self.arguments = arguments
        self.callId = callId
        self.name = name
        self.id = id
        self.status = status
    }
    
    public let arguments: String
    public let callId: String
    public let name: String
    public let type = "function_call"
    public let id: String?
    public let status: String?
    
    enum CodingKeys: String, CodingKey {
        case arguments
        case callId = "call_id"
        case name, type, id, status
    }
}

// MARK: - FunctionToolCallOutput

/// Function tool call output
public struct FunctionToolCallOutput: Codable, Sendable {
    public let callId: String
    public let output: String
    public let type = "function_call_output"
    public let id: String?
    public let status: String?
    
    public init(callId: String, output: String, id: String? = nil, status: String? = nil) {
        self.callId = callId
        self.output = output
        self.id = id
        self.status = status
    }
    
    enum CodingKeys: String, CodingKey {
        case callId = "call_id"
        case output, type, id, status
    }
}
